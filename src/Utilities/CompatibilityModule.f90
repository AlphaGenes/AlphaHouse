module CompatibilityModule
	use integerLinkedListModule

	type bimHolder
	contains
		character :: ref,alt
		character(len=IDLENGTH) :: id
		integer :: chom
		integer(kind=int64) :: pos, chrompos
	end type bimHolder

	type Chromosome
	contains
		type(integerLinkedList) :: snps

        final :: destroyChrom
	end type chromsome
	contains
		!###############################################################################

		!-------------------------------------------------------------------------------
		! The Roslin Institute, The University of Edinburgh - AlphaGenes Group
		!-------------------------------------------------------------------------------
		!
		!> @file     CompatibilityModule.f90
		!
		! DESCRIPTION:
		!> @brief    Module cotaining subroutines to deal with text PLINK format
		!> @details  currently only contains integer and real heap sort procedures
		!
		!> @author   David Wilson, david.wilson@roslin.ed.ac.uk
		!
		!> @date     January 4, 2017
		!
		!> @version  1.0.0
		!
		!
		!-------------------------------------------------------------------------------


        subroutine destroyChrom(chrom) 


            class(Chromosome) :: chrom

            call chrom%snps%destroyLinkedList()

        end subroutine





		function readToPedigreeFormat(pedFile) result(ped)
			use ConstantModule, only : IDLENGTH
			use AlphaHouseMod, only : countLines
			use PedigreeModule

			type(pedigreeHolder) :: ped !< Pedigree object that is returned
			character(len=*), intent(in) :: pedFile !< .ped file generated by plink
			character(len=IDLENGTH) :: familyID,gender,phenotype
			integer :: fileUnit,stat, i,lines
			character(len=IDLENGTH),dimension(:,:), allocatable :: pedArray
			integer, allocatable, dimension(:) :: genderArray, phenotypeArray

			lines=  countLines(pedFile)

			allocate(pedArray(3,lines))
			allocate(genderArray(lines))
			allocate(phenotypeArray(lines))

			open(newUnit=fileUnit, file=pedFile, status="old")
			do i=1, lines
				read(fileUnit,*) familyID,pedArray(1,i),pedArray(2,i),pedArray(3,i),gender,phenotype

				read(gender,*,iostat=stat)  genderArray(i)
				read(phenotype,*,iostat=stat)  phenotypeArray(i)
			enddo


			ped = PedigreeHolder(pedArray, genderArray)



		end function readToPedigreeFormat


		subroutine readPlink(binaryFilePre, outfile, missing, ped)
			use AlphaHouseMod, only : CountLines
			use PedigreeModule
			character(len=*),intent(in) :: binaryFilePre, outfile,missing
			integer :: fam,bim,bed
			type(pedigreeholder), intent(out) :: ped
			type(dictStruct) :: dict
			integer,intent(out) :: masked
			integer,intent(out) :: maxChroms
			type(bimHolder) , allocatable, dimension(:), intent(out) :: bimInfo
			integer, dimension(:), allocatable :: snps
            type(Chromosome), intent(out),dimension(:), allocatable :: chroms
			logical, dimension(:), allocatable :: maskedLogi
			! integer, allocatable
			open(newUnit=fam, file=binaryFilePre//".fam", status='old')
			open(newUnit=bim, file=binaryFilePre//".bim", status='old')
			open(newUnit=bed, file=binaryFilePre//".bed", status='old')

			ped = readToPedigreeFormat(binaryFilePre//".fam")

			call readBim(binaryFilePre//".bim",dict,bimInfo,nsnps,maxChroms)

			call readplinkSnps(binaryFilePre//".bim",nsnps,ped,chroms,allsnsps)

			allocate(maskedLogi(size(allSnps(1,:))))
			do i =1, maxChroms

				masked = chroms(i)%snps%convertToArray()
				maskedLogi = .false.
				do h =1, size(masked)
					maskedLogi(masked(h)) = .true.

				enddo
				do p=1,ped%pedigreeSize
					write(outChrFile,*) pack(allSnps(p,:), masksnps
				do h=1,size(snps)
					

				enddo 
				end subroutine readPlink







				subroutine readBim(bimFile, dict, bimInfo,nsnps,chroms, maxChroms)

					character(len=*), intent(in) :: bimFile
					type(dictStruct) :: dict
					character :: ref,alt
					character(len=IDLENGTH) :: id
					integer :: chom
					integer(kind=int64) :: pos, chrompos

					integer,intent(out) :: nsnps
					integer,intent(out) :: maxChroms

					type(bimHolder) , allocatable, dimension(:), intent(out) :: bimInfo
                    type(Chromosome), intent(out),dimension(:), allocatable, intent(out) :: chroms
					maxChroms = 0
                    

					nsnps = countLines(bimFile)
                    allocate(chroms(LARGECHROMNUMBER))
					allocate(bimInfo(nsnps))
					do i =1, nsnps

						read(unit, *) chrom, id,chrompos, pos ,ref, alt

						if (chrom > maxChroms) then
							maxChroms = chrom
						endif
                        
						call dict%addKey(id, i)
						bimInfo(i)%chrom = chrom

						bimInfo(i)%id = id

                        
						bimInfo%chrompos = chrompos
						bimInfo%pos = pos
						bimInfo%ref = ref
						bimInfo%alt = alt

                        chroms(chrom)%snps%list_add(i)
					end do


				end subroutine readBim

				! Stores entire genotype file in memory
				subroutine readplinkSnps(bed, ncol,ped, minor,snps, status)

					use PedigreeModule
					use genotypeModule
					implicit none

					! Arguments
					character(*), intent(in) :: bed
					integer, intent(in) :: ncol, nlines, na, minor
					integer, intent(out) :: status
					type(PedigreeHolder), intent(in) :: ped
                    
					!! Types
					INTEGER, PARAMETER :: Byte = SELECTED_INT_KIND(1) ! Byte

					!! Local arguments
					integer(Byte) :: readplinkmode, element, plinkmode
					integer(Byte), dimension(2) :: readmagicnumber, magicnumber
					!logical :: checkmaf
					integer :: stat, i, j, k, snpcount, majorcount
					integer, dimension(4) :: codes
					!integer, dimension(:), allocatable :: domasksnps
					integer(kind=1), dimension(:,:), allocatable,intent(out) ::  snps
					real :: allelefreq
					character(100) :: nChar, fmt

					integer :: bedInUnit
					! Supported formats as per plink 1.9.
					!data magicnumber/X"6C",X'0000001B' /,  plinkmode/X'01'/
					data magicnumber /108,27/, plinkmode /1/

					allocate(snps(ped%pedigreeSize,ncol))
					snps(:,:) = 9


					if (minor == 1) then
						codes = (/ 0, 1, 2, na /)
					else
						codes = (/ 2, 1, 0, na /)
					endif

					open(bedInUnit, file=bed, status='OLD', ACCESS='STREAM', FORM='UNFORMATTED')
					read(bedInUnit) readmagicnumber, readplinkmode
					if (all(readmagicnumber /= magicnumber) ) then
						status=-1
						close(bedInUnit)
						return
					endif
					if (readplinkmode /= plinkmode) then
						status=-2
						close(bedInUnit)
						return
					endif


					j=0  ! Sample-index
					k=1  ! SNP-index
					snpcount = 0
					majorcount = 0
					outer: do
						read(bedInUnit, iostat=stat) element
						if (stat /= 0) exit
						inner: do i=0,6,2
							j = j + 1
							snpcount = snpcount + 1
							select case(IBITS(element, i, 2))
								case (0) ! homozygote
								snps(j,k) = codes(1)
								case (1) ! missing
								snps(j,k) = codes(4)
								snpcount = snpcount - 1
								case (2) ! heterozygote
								snps(j,k) = codes(2)
								majorcount = majorcount + 1
								case (3) ! homozygote, minor
								snps(j,k) = codes(3)
								majorcount = majorcount + 2
							endselect
							if (j == nlines) then
								if (snpcount /= 0) then
									allelefreq = majorcount / (snpcount*2.)
								endif
								j = 0
								snpcount = 0
								majorcount = 0
								k = k + 1
								cycle outer
							endif
						enddo inner
					enddo outer
					close(bedInUnit)

					if (stat == -1) stat=0

					! Write output
					fmt='(i20,'//trim(adjustl(nChar))//'I2)'
					!print *, fmt



					! do i=1,nlines
					! 	ped%pedigree(i)%individualGenotype = NewGenotypeInt(pack(snps(i,:), masksnps))
					! enddo

					deallocate(snps)

					!print *, 'readplinksimple is done.'

				end subroutine readplinkSnps


		end module CompatibilityModule



