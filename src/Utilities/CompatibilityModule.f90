#ifdef _WIN32

#define STRINGIFY(x)#x
#define TOSTRING(x) STRINGIFY(x)

#DEFINE DASH "\"
#DEFINE COPY "copy"
#DEFINE MD "md"
#DEFINE RMDIR "RMDIR /S /Q"
#DEFINE RM "del"
#DEFINE RENAME "MOVE /Y"
#DEFINE SH "BAT"
#DEFINE EXE ".exe"
#DEFINE NULL " >NUL"


#else

#define STRINGIFY(x)#x
#define TOSTRING(x) STRINGIFY(x)

#DEFINE DASH "/"
#DEFINE COPY "cp"
#DEFINE MD "mkdir"
#DEFINE RMDIR "rm -r"
#DEFINE RM "rm"
#DEFINE RENAME "mv"
#DEFINE SH "sh"
#DEFINE EXE ""
#DEFINE NULL ""


#endif
!###############################################################################

!-------------------------------------------------------------------------------
! The Roslin Institute, The University of Edinburgh - AlphaGenes Group
!-------------------------------------------------------------------------------
!
!> @file     CompatibilityModule.f90
!
! DESCRIPTION:
!> @brief    Module cotaining subroutines to deal with text PLINK format
!> @details  currently only contains integer and real heap sort procedures
!
!> @author   David Wilson, david.wilson@roslin.ed.ac.uk
!
!> @date     January 4, 2017
!
!> @version  1.0.0
!
!
!-------------------------------------------------------------------------------
module CompatibilityModule
	use integerLinkedListModule
	use HashModule
	use PedigreeModule

	implicit none

	type :: bimHolder
	character(len=2) :: ref,alt
	character(len=IDLENGTH) :: id
	character(len=2) :: chrom !<either an integer, or 'X'/'Y'/'XY'/'MT'
	integer(kind=int64) :: pos, chrompos
end type bimHolder

type Chromosome

type(integerLinkedList) :: snps
end type Chromosome


type plinkInfoType

	type(chromosome), dimension(:), allocatable :: chromosomes

	integer :: nChroms !< total number of chromosomes
	integer :: totalSnps !< total numbers of snps across all chromosomes
	character(len=2), dimension(:),allocatable :: referenceAllelePerSnps, alternateAllelePerSnps 
	integer(kind=1), dimension(:,:), allocatable ::  genotypes	 !<  genotypes for all chroms (nanimals, totalsnps)
	integer(kind=1), dimension(:,:,:), allocatable ::  phase
	type(DictStructure ) :: dict
	real(real64), dimension(:,:) ,allocatable :: lengths !< array of snp lengths in morgans, in format (chrom, snps)
	integer, dimension(:,:) ,allocatable :: basepairs !< array of basepair positions, in format (chrom, snps)
	integer :: sexChrom = 0 !<if not 0, then this is the sex chrom
	integer, dimension(:), allocatable :: nsnpsPerChromosome !< nsnps per chromosome
end type plinkInfoType
contains






!---------------------------------------------------------------------------
!< @brief reads fam file to pedigree object
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2016
!---------------------------------------------------------------------------
subroutine readFamFile(ped,pedFile)
	use ConstantModule, only : IDLENGTH
	use AlphaHouseMod, only : countLines
	use PedigreeModule

	type(pedigreeHolder), intent(out) :: ped !< Pedigree object that is returned
	character(len=*), intent(in) :: pedFile !< .ped file generated by plink
	character(len=IDLENGTH) :: familyID,gender,phenotype
	integer :: fileUnit,stat, i,lines
	character(len=IDLENGTH),dimension(:,:), allocatable :: pedArray
	integer, allocatable, dimension(:) :: genderArray, phenotypeArray

	lines=  countLines(pedFile)

	allocate(pedArray(3,lines))
	allocate(genderArray(lines))
	allocate(phenotypeArray(lines))

	open(newUnit=fileUnit, file=pedFile, status="old")
	print *,"TOTAL ANS",lines
	do i=1, lines
		read(fileUnit,*) familyID,pedArray(1,i),pedArray(2,i),pedArray(3,i),gender,phenotype



		! TODO potentially add family ID here to animals
		! pedArray(1,i) = familyID // ":" // pedArray(1,i)
		! pedArray(2,i) = familyID // ":" // pedArray(2,i)
		! pedArray(3,i) = familyID // ":" // pedArray(3,i)

		! write(*,'(3a20)') pedArray(1,i),pedArray(2,i),pedArray(3,i)
		read(gender,*,iostat=stat)  genderArray(i)
		read(phenotype,*,iostat=stat)  phenotypeArray(i)
	enddo


	call initPedigreeArrays(ped,pedArray, genderArray)

	print *, "ANS in ped",ped%pedigreeSize," without dum:",ped%addedRealAnimals

	call ped%printPedigreeOriginalFormat("pedigreeOutput.txt")

end subroutine readFamFile

!---------------------------------------------------------------------------
!< @brief Reads PLINK binary format into ped datastructures
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2016
!---------------------------------------------------------------------------
subroutine readPlink(binaryFilePre, ped, outputPaths,nsnps, sexChrom)
	use HashModule
	use PedigreeModule

	character(len=*),intent(in) :: binaryFilePre !< part before file extension
	type(pedigreeholder), intent(out) :: ped !< pedigree object returned
	integer, intent(out) :: sexChrom !< true if a sex chromosome is present
	integer,dimension(:), allocatable, intent(out) :: nsnps !< number of snps per chromosome
	character(len=128), dimension(:), allocatable, intent(out) :: outputPaths !< output paths for each chromosome
	type(bimHolder) , allocatable, dimension(:) :: bimInfo
	type(plinkInfoType) :: plinkInfo

	! TODO change to pointer rather than copy
	call readFamFile(ped,trim(binaryFilePre)//".fam")
	call readBim(trim(binaryFilePre)//".bim",bimInfo,plinkInfo)
	print *,"READ BIM"
	call readBED(trim(binaryFilePre)//".bed",ped,4,plinkInfo)
	print *,"READ BED"

	call createOutputFiles(ped, outputPaths,plinkInfo)


	nsnps = plinkInfo%nsnpsPerChromosome
	sexChrom = plinkInfo%sexChrom
end subroutine readPlink

!---------------------------------------------------------------------------
!< @brief writes output files
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2017
!---------------------------------------------------------------------------
subroutine createOutputFiles(ped, outputPaths,plinkInfo)
	use ifport
	use ALphaHouseMod, only : countLines

	type(pedigreeholder), intent(in) :: ped !< pedigree object taken in
	type(plinkInfoType), intent(in) :: plinkInfo
	character(len=128), dimension(:), allocatable,intent(out) :: outputPaths !< returns the output path for each chromosome

	integer :: outChrF, outChrP,bpFile,lengthFile
	character(len=128) :: path, outChrFile,fmt
	logical, dimension(:), allocatable :: maskedLogi
	integer, dimension(:), allocatable :: masked
	integer :: result, i, h,p,refAlleleUnit,count
	integer(kind=1),allocatable,dimension (:,:) :: array
	path = "fullGenome/"
	result=makedirqq(path)

	print *, "Total number of Chromosomes:",plinkInfo%nChroms

	allocate(outputPaths(plinkInfo%nChroms))
	allocate(maskedLogi(size(plinkInfo%genotypes,2))) !< alloc to total number of snps
	do i =1, plinkInfo%nChroms

		write(outChrFile, '(a,a,i0.2,a)') trim(path),trim("chr"),i,DASH

		result=makedirqq(outChrFile)
		outputPaths(i) = outChrFile

		open(newunit=outChrF, file=trim(outChrFile)//"genotypes.txt", status="unknown")
		open(newunit=outChrP, file=trim(outChrFile)//"phase.txt", status="unknown")
		open(newunit=lengthFile, file=trim(outChrFile)//"snplengths.txt", status="unknown")
		open(newunit=bpFile, file=trim(outChrFile)//"snpBasepairs.txt", status="unknown")

		!< uses genotype mask to determine which snps to use
		masked = plinkInfo%chromosomes(i)%snps%convertToArray()
		maskedLogi = .false.
		do h =1, size(masked)
			maskedLogi(masked(h)) = .true.
		enddo

	
		open(newunit=refAlleleUnit, file=trim(outChrFile)//"refAlleles", status="unknown")

		! alleles = pack(referenceAllelePerSnps, maskedLogi)

		write(refAlleleUnit, '(3a)') "snp in Chrom", "snp pos","Ref Allele"
		count = 0
		do p=1, size(plinkInfo%referenceAllelePerSnps)
			! do p=1,size(alleles)
			! write(refAlleleUnit, '(1i5,a5)') p, referenceAllelePerSnps(p)
			if (maskedLogi(p)) then
				count = count +1
				write(refAlleleUnit, '(2i5,a5)') count,p, plinkInfo%referenceAllelePerSnps(p)
			endif
		enddo
			close(refAlleleUnit)
		

		allocate(array(ped%addedRealAnimals, plinkInfo%nsnpsPerChromosome(i)))
		write(fmt, '(a,i10,a)')  "(a20,", plinkInfo%nsnpsPerChromosome(i), "i3)"
		! set up the pedigree to avoid read in
		! array = 9
		! do p=1,ped%addedRealAnimals
		! 	array(p,:) = pack(plinkInfo%genotypes(p,:), maskedLogi)
		! end do

		write(lengthFile, *) pack(plinkInfo%lengths(i,:), maskedLogi)
		write(bpFile, *) pack(plinkInfo%basepairs(i,:), maskedLogi)

		do p=1,ped%addedRealAnimals
			write(outChrF,fmt) ped%pedigree(p)%originalId,pack(plinkInfo%genotypes(p,:), maskedLogi)
			write(outChrp,fmt) ped%pedigree(p)%originalId,pack(plinkInfo%phase(p,:,1), maskedLogi)
			write(outChrp,fmt) ped%pedigree(p)%originalId,pack(plinkInfo%phase(p,:,2), maskedLogi)
		end do
		print *, "Finished writeout of chromosome ", i

		close(outChrF)
		close(outChrF)
		close(outChrP)
		close(lengthFile)
		close(bpFile)
		deallocate(array)
	enddo


end subroutine createOutputFiles



!---------------------------------------------------------------------------
!< @brief Reads bim file to datastructures
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2016
!---------------------------------------------------------------------------
subroutine readBim(bimFile, bimInfo,plinkInfo)
	use HashModule
	use AlphaHouseMod
	use ConstantModule

	character(len=*), intent(in) :: bimFile
	type(bimHolder) , allocatable, dimension(:), intent(out) :: bimInfo !< extra info provided by BIM file
	type(plinkInfoType), intent(out) :: plinkInfo
	character :: ref,alt
	character(len=IDLENGTH) :: id

	integer(kind=int64) :: pos
	real(kind=real64) :: chrompos

	real(kind=real64), dimension(:,:) ,allocatable :: tmpLengths
	integer, dimension(:,:) ,allocatable :: tmpbasePairs
	integer, dimension(:), allocatable :: temparray

	integer :: i, unit,chromCount,curChromSnpCount
	character(len=2) :: chrom,prevChrom

	plinkInfo%nChroms = 0
	curChromSnpCount = 0
	allocate(plinkInfo%nsnpsPerChromosome(LARGECHROMNUMBER))
	plinkInfo%nsnpsPerChromosome = 0
	call plinkInfo%dict%DictStructure()
	plinkInfo%totalSnps = countLines(bimFile)

	open(newUnit=unit, file=bimFile, status='old')
	allocate(plinkInfo%chromosomes(LARGECHROMNUMBER))
	allocate(bimInfo(plinkInfo%totalSnps))
	allocate(plinkInfo%lengths(LARGECHROMNUMBER,plinkInfo%totalSnps))
	allocate(plinkInfo%basepairs(LARGECHROMNUMBER,plinkInfo%totalSnps))
	chromCount = 1
	do i =1, plinkInfo%totalSnps

		read(unit, *) chrom, id,chrompos, pos ,ref, alt

		if (i == 1) then
			prevChrom = chrom
		endif

		! if we've moved on to the next chromsome


		! if we 've moved on to the next chromosome
		if (chrom /=prevChrom .or. i == plinkInfo%totalSnps) then

			! set the count to he current numbers
			if (i == plinkInfo%totalSnps) then
				curChromSnpCount = curChromSnpCount + 1
			endif
			plinkInfo%nsnpsPerChromosome(chromCount) = curChromSnpCount
			curChromSnpCount = 0
			chromCount = chromCount + 1

			prevChrom = chrom

				if (chrom == "X" .or. chrom == 'Y') then
					plinkInfo%sexChrom = chromCount 
				endif
				if (chrom == 'XY' .or. chrom == 'MT') then
					write(error_unit,*) "WARNING - No support currently for XY or MT chromosomes"
				endif

			if (chromCount > plinkInfo%nChroms) then
				plinkInfo%nChroms = chromCount
			endif
		endif

		curChromSnpCount = curChromSnpCount + 1

		plinkInfo%lengths(chromCount,curChromSnpCount) = chromPos
		plinkInfo%basepairs(chromCount,curChromSnpCount) = pos

		call plinkInfo%dict%addKey(id, i)

		bimInfo(i)%chrom = chrom
		!  TODO clean this up

		bimInfo(i)%id = id


		bimInfo(i)%chrompos = chrompos
		bimInfo(i)%pos = pos
		bimInfo(i)%ref = ref
		bimInfo(i)%alt = alt

		call plinkInfo%chromosomes(chromCount)%snps%list_add(i)
	end do

	plinkInfo%nChroms = plinkInfo%nChroms -1
	chromCount = chromCount - 1

	if (chromCount /= LARGECHROMNUMBER) then
		allocate(temparray(chromCount))
		temparray(1:chromCount) = plinkInfo%nsnpsPerChromosome(1:chromCount)
		call move_alloc(temparray,plinkInfo%nsnpsPerChromosome)

		allocate(tmpLengths(chromCount,plinkInfo%totalSnps))
		tmpLengths(1:chromCount,:) = plinkInfo%lengths(1:chromCount,:)
		call move_alloc(tmpLengths,plinkInfo%lengths)


		allocate(tmpbasePairs(chromCount,plinkInfo%totalSnps))
		tmpbasePairs(1:chromCount,:) = plinkInfo%basepairs(1:chromCount,:)
		call move_alloc(tmpbasePairs,plinkInfo%basepairs)
	endif
	close (unit)


end subroutine readBim

!---------------------------------------------------------------------------
!< @brief Reads BED Files
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2017
!---------------------------------------------------------------------------
subroutine readBED(bed, ped, minor, plinkInfo)

	use PedigreeModule
	use genotypeModule
	implicit none

	! Arguments
	character(*), intent(in) :: bed !< bed file name
	type(PedigreeHolder), intent(in) :: ped !< pedigree read in from .fam
	integer, intent(in) ::  minor !< if the first allele is minor or major
	type(plinkInfoType), intent(inout) :: plinkInfo
	integer :: status

	!! Types
	INTEGER, PARAMETER :: Byte = SELECTED_INT_KIND(1) ! Byte

	!! Local arguments
	integer(Byte) :: readplinkmode, element, plinkmode
	integer(Byte), dimension(2) :: readmagicnumber, magicnumber
	!logical :: checkmaf
	integer :: stat, i, j, k, snpcount, majorcount
	integer, dimension(4) :: codes, phasecodes
	!integer, dimension(:), allocatable :: domasksnps
	real :: allelefreq
	integer :: bedInUnit
	! Supported formats as per plink 1.9.
	!data magicnumber/X"6C",X'0000001B' /,  plinkmode/X'01'/
	data magicnumber /108,27/, plinkmode /1/


	print *,"start BED read"
	allocate(plinkInfo%genotypes(ped%addedRealAnimals,plinkInfo%totalSnps))
	allocate(plinkInfo%phase(ped%addedRealAnimals,plinkInfo%totalSnps,2))
	plinkInfo%genotypes(:,:) = MISSINGGENOTYPECODE
	plinkInfo%phase(:,:,:) = MISSINGPHASECODE

	if (minor == 1) then
		codes = (/ 0, 1, 2, MISSINGGENOTYPECODE /)
		phaseCodes = (/ 0, 1, 1, MISSINGGENOTYPECODE /)
	else
		codes = (/ 2, 1, 0, MISSINGGENOTYPECODE /)
		phaseCodes = (/ 1, 1, 0, MISSINGGENOTYPECODE /)
	endif

	open(newunit=bedInUnit, file=bed, status='OLD', ACCESS='STREAM', FORM='UNFORMATTED')
	print *, "start read"
	read(bedInUnit) readmagicnumber, readplinkmode
	if (all(readmagicnumber /= magicnumber) ) then
		status=-1
		close(bedInUnit)
		return
	endif
	if (readplinkmode /= plinkmode) then
		status=-2
		close(bedInUnit)
		return
	endif


	j=0  ! Sample-index
	k=1  ! SNP-index
	snpcount = 0
	majorcount = 0
	outer: do


		read(bedInUnit, iostat=stat) element
		if (stat /= 0) exit
		inner: do i=0,6,2
			j = j + 1
			snpcount = snpcount + 1
			select case(IBITS(element, i, 2))
				case (0) ! homozygote
				plinkInfo%genotypes(j,k) = codes(1)
				plinkInfo%phase(j,k,:) = phasecodes(1)
				case (1) ! missing
				plinkInfo%genotypes(j,k) = codes(4)
				plinkInfo%phase(j,k,:) = phaseCodes(4)
				snpcount = snpcount - 1
				case (2) ! heterozygote
				plinkInfo%genotypes(j,k) = codes(2)
				! Set to missing - as we don't know which snp is which
				plinkInfo%phase(j,k,1) = MISSINGPHASECODE
				plinkInfo%phase(j,k,2) = MISSINGPHASECODE
				majorcount = majorcount + 1
				case (3) ! homozygote, minor
				plinkInfo%genotypes(j,k) = codes(3)
				plinkInfo%phase(j,k,:) = phasecodes(3)
				majorcount = majorcount + 2
			endselect
			if (j == ped%addedRealAnimals) then
				if (snpcount /= 0) then
					allelefreq = majorcount / (snpcount*2.)
				endif
				j = 0
				snpcount = 0
				majorcount = 0
				k = k + 1
				cycle outer
			endif
		enddo inner
		! print *, "in outer"
	enddo outer
	close(bedInUnit)

	if (stat == -1) stat=0

	print *, "finished"

end subroutine readBED

!---------------------------------------------------------------------------
!< @brief Reads PLINK non binary version .map, .ref(optional) and .ped files
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2017
!---------------------------------------------------------------------------
subroutine readPlinkNoneBinary(filePre,ped,outputPaths ,nsnps,sexChrom)
	use HashModule
	use PedigreeModule
	use AlphaHouseMod
	use ifport

	character(len=*),intent(in) :: filePre
	character(len=128), dimension(:), allocatable,intent(out) :: outputPaths
	integer, dimension(:) ,allocatable, intent(out) :: nsnps

	integer,intent(out) :: sexChrom


	type(plinkInfoType) :: plinkInfo
	type(DictStructure) :: dict
	type(pedigreeHolder) :: ped

	call readMap(trim(filePre)//".map",plinkInfo)
	call readRef(trim(filePre)//".ref", plinkInfo)
	call readPedFile(trim(filePre)//".ped",ped, plinkInfo)
	call createOutputFiles(ped, outputPaths,plinkInfo)
	nsnps = plinkInfo%nsnpsPerChromosome
	sexChrom = sexChrom
end subroutine readPlinkNoneBinary


!---------------------------------------------------------------------------
!< @brief Reads plink map file into datastructures
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2016
!---------------------------------------------------------------------------
subroutine readMap(filename,plinkInfo)
	use HashModule
	use AlphaHouseMod

	character(len=*),intent(in) :: filename

	type(plinkInfoType), intent(out) :: plinkInfo

	integer, dimension(:) ,allocatable :: tempArray
	real(real64), dimension(:,:) ,allocatable ::tmpLengths
	integer, dimension(:,:) ,allocatable :: tmpbasePairs
	integer :: unit,i,chromCount,basepair

	real(kind=real64) :: length
	logical :: hasSexChrom
	character(len=2) :: chrom,prevChrom
	character(len=128) :: id

	plinkInfo%totalSnps = countLines(fileName)
	print *,"TOTAL SNPS IN MAP:", plinkInfo%totalSnps
	open(newunit=unit, file=filename, status='OLD')

	allocate(plinkInfo%chromosomes(LARGECHROMNUMBER))
	allocate(plinkInfo%lengths(LARGECHROMNUMBER, plinkInfo%totalSnps))
	allocate(plinkInfo%basepairs(LARGECHROMNUMBER, plinkInfo%totalSnps))

	allocate(plinkInfo%nsnpsPerChromosome(LARGECHROMNUMBER))

	call plinkInfo%dict%DictStructure()
	plinkInfo%nChroms = 0
	plinkInfo%nsnpsPerChromosome = 0
	chromCount = 0
	prevChrom = 'MT'

	write(*,*) "Start reading map file"
	do i=1,plinkInfo%totalSnps

		read(unit, *) chrom, id,length, basepair

		if (chrom /=prevChrom) then
			chromCount = chromCount + 1
			prevChrom = chrom
			if (chrom == "X" .or. chrom == 'Y') then
				plinkInfo%sexChrom = chromCount
			endif
			if (chrom == 'XY' .or. chrom == 'MT') then
				write(error_unit,*) "WARNING - No support currently for XY or MT chromosomes"
			endif
		endif

		plinkInfo%nsnpsPerChromosome(chromCount) = plinkInfo%nsnpsPerChromosome(chromCount) + 1
		plinkInfo%lengths(chromCount,plinkInfo%nsnpsPerChromosome(chromCount)) = length
		plinkInfo%basepairs(chromCount,plinkInfo%nsnpsPerChromosome(chromCount) ) = basepair
		call plinkInfo%dict%addKey(id, i)
		call plinkInfo%chromosomes(chromCount)%snps%list_add(i)
	enddo

	if (chromCount /= LARGECHROMNUMBER) then
		allocate(temparray(chromCount))
		temparray(1:chromCount) = plinkInfo%nsnpsPerChromosome(1:chromCount)
		call move_alloc(temparray,plinkInfo%nsnpsPerChromosome)

		allocate(tmpLengths(chromCount,plinkInfo%totalSnps))
		tmpLengths(1:chromCount,:) = plinkInfo%lengths(1:chromCount,:)
		call move_alloc(tmpLengths,plinkInfo%lengths)


		allocate(tmpbasePairs(chromCount,plinkInfo%totalSnps))
		tmpbasePairs(1:chromCount,:) = plinkInfo%basepairs(1:chromCount,:)
		call move_alloc(tmpbasePairs,plinkInfo%basepairs)
	endif

	plinkInfo%nChroms = chromCount
	write(*,*) "Finished reading map file"
end subroutine readMap


!---------------------------------------------------------------------------
!< @brief Sets the individual to be genotyped at high density.
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2016
!---------------------------------------------------------------------------
subroutine readPedFile(filename,ped, plinkInfo)
	use PedigreeModule
	use ConstantModule
	use AlphaHouseMod

	character(len=*), intent(in) :: filename
	type(pedigreeHolder), intent(out) :: ped

	character(len=IDLENGTH), dimension(:,:), allocatable :: pedArray
	type(plinkInfoType), intent(inout) :: plinkInfo
	character(len=2),dimension(:,:), allocatable :: alleles !<(nanimals. nsnp*2) size nsnp x2 (for each allele,)
	integer, allocatable, dimension(:) :: genderArray, phenotypeArray
	integer :: size,cursnp,i,j,stat, fileUnit,gender,phenotype
	character(len=1) :: all1, all2
	character(len=IDLENGTH),dimension(:),allocatable :: FAMILYID
	integer, dimension(4) :: codes,phaseCodes
	integer :: minor

	size = countlines(filename)

	allocate(familyID(size))
	allocate(pedArray(3,size))
	allocate(genderArray(size))
	allocate(phenotypeArray(size))



	allocate(alleles(size, plinkInfo%totalSnps*2))
	allocate(plinkInfo%phase(size,plinkInfo%totalSnps,2))
	allocate(plinkInfo%genotypes(size,plinkInfo%totalSnps))

	plinkInfo%genotypes(:,:) = MISSINGGENOTYPECODE
	plinkInfo%phase(:,:,:) = MISSINGPHASECODE
	open(newunit=fileUnit, file=fileName, status="unknown")

	! minor is always false atm - this is because we always want the same ref allele to be used here - potentially used for future
	minor = 4
	if (minor == 1) then
		codes = (/ 0, 1, 2, MISSINGGENOTYPECODE /)
		phaseCodes = (/ 0, 1, 1, MISSINGPHASECODE /)
	else
		codes = (/ 2, 1, 0, MISSINGGENOTYPECODE /)
		phaseCodes = (/ 1, 1, 0, MISSINGPHASECODE /)
	endif
	write(*,*) "Start Reading Ped File"
	do i=1,size
		read(fileUnit,*) familyID(i),pedArray(1,i),pedArray(2,i),pedArray(3,i),gender,phenotype, alleles(i,:)

		read(gender,*,iostat=stat)  genderArray(i)
		read(phenotype,*,iostat=stat)  phenotypeArray(i)
	enddo

	close(fileUnit)

		! check if reference alleles have been passed in
	if (.not. allocated(plinkInfo%referenceAllelePerSnps)) then
		allocate(plinkInfo%referenceAllelePerSnps(plinkInfo%totalSnps))
		allocate(plinkInfo%alternateAllelePerSnps(plinkInfo%totalSnps))

		do j=1,plinkInfo%totalSnps*2,2
			cursnp = (j/2) + 1
			block
				character(len=2) :: one,two
				integer :: onec,twoc
				one = getFirstNonMissing(alleles, j)
				onec = 0
				twoc = 0
				do i=1,size
					all1 = alleles(i,j)
					all2 = alleles(i,j+1)
					! check for first allele
					if (all1 == one ) then
						onec = onec + 1
					else
						if (all2 == '0') cycle
						if (twoc == 0) then
							two = all1
						endif

						twoc = twoc + 1
					endif
					! check for second allele
					if (all2 == one ) then
						onec = onec + 1
					else
					if (all2 == '0') cycle
						if (twoc == 0) then
							two = all1
						endif
						twoc = twoc + 1
					endif
				enddo
				if (onec < twoc) then
					plinkInfo%referenceAllelePerSnps(cursnp) = one
					plinkInfo%alternateAllelePerSnps(cursnp) = two
				else
					plinkInfo%referenceAllelePerSnps(cursnp) = two
					plinkInfo%alternateAllelePerSnps(cursnp) = one
				endif
			end block
		enddo
	endif

	do j=1,plinkInfo%totalSnps*2,2
		cursnp = (j/2) + 1
		! ref is always the first - allele in snp -
		! referenceAllelePerSnps(cursnp) = alleles(i,j+1)
		! if (.not. allocated(referenceAllelePerSnps)) then
		! 	referenceAllelePerSnps(cursnp) = getFirstHetPosition(alleles, cursnp)
		! endif
		do i=1,size !< loop through animals
			all1 = alleles(i,j)
			all2 = alleles(i,j+1)
			if (all1 == '0' .or. all2 == '0') then
				plinkInfo%genotypes(i,curSnp) = MISSINGGENOTYPECODE

			else if (all1 == all2) then

				if (all1 == plinkInfo%referenceAllelePerSnps(curSnp) ) then
					plinkInfo%genotypes(i,curSnp) = codes(1)
					plinkInfo%phase(i,cursnp,:) = phasecodes(1)
				else
					plinkInfo%genotypes(i,curSnp) = codes(3)
					plinkInfo%phase(i,cursnp,:) = phasecodes(3)

				endif
			else !< means they are different
				plinkInfo%genotypes(i,curSnp) = codes(2)

				if (all1 == plinkInfo%referenceAllelePerSnps(cursnp)) then
					plinkInfo%phase(i,cursnp,1) = phasecodes(3)
					plinkInfo%phase(i,cursnp,2) =  phasecodes(1)
				else
					plinkInfo%phase(i,cursnp,1) = phasecodes(1)
					plinkInfo%phase(i,cursnp,2) = phasecodes(3)
				endif

			endif
		enddo
	enddo
	write(*,*) "Finished Reading Ped File"
	call initPedigreeArrays(ped,pedArray, genderArray)

end subroutine readPedFile


!---------------------------------------------------------------------------
!< @brief Returns the first non missing character in allele array
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2016
!---------------------------------------------------------------------------
character function getFirstNonMissing(alleles, snp)
	character(len=2),dimension(:,:), allocatable, intent(in) :: alleles !< alleles, in format (nanimals, nsnps)
	integer, intent(in) :: snp
	integer :: i, h
	do i=1, size(alleles,1) !< loops through number of animals
		do h=snp,snp+1
			if (alleles(i,h) /= '0') then
				getFirstNonMissing = alleles(i,h)
				return
			endif
		enddo
	enddo

	write(error_unit,*) "WARNING - no reference alleles for snp!"
	getFirstNonMissing = '0'
end function getFirstNonMissing




!---------------------------------------------------------------------------
!< @brief returns the first snp that is a het at position pos
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2017
!---------------------------------------------------------------------------
character function getFirstHetPosition(alleles, snp)
	character(len=2),dimension(:,:), allocatable, intent(in) :: alleles
	character(len=2) :: all1, all2
	integer, intent(in) :: snp !< snp position
	integer :: i, h

	do i=1, size(alleles,1) !< loops through number of animals
		all1 = alleles(i,snp)
		all2 = alleles(i,snp+1)

		! adds support for number format
		if (all1 == "1" .or. all2 == "1") then
			getFirstHetPosition = "1"
			return
		endif
		if (all1 == all2) then
			cycle
		else
			getFirstHetPosition = all1
			return
		endif
	enddo

	write(error_unit,*) "WARNING - no reference alleles for snp!"
	getFirstHetPosition = all1
end function getFirstHetPosition


!---------------------------------------------------------------------------
!< @brief gets reference alleles from ref file if it exists there
!< @author  David Wilson david.wilson@roslin.ed.ac.uk
!< @date    October 26, 2017
!---------------------------------------------------------------------------
subroutine readRef(file, plinkInfo)
	use AlphaHouseMod, only :countLines
	character(len=*),intent(in) :: file
	type(plinkInfoType),intent(inout) :: plinkInfo

	character(len=2) :: refAllele, minor,id
	logical :: fileExists
	integer :: lines,i, unit,snpId

	inquire( file=file, exist=fileExists )


	if (fileExists) then

		lines = countLines(file)
		open(newunit=unit, file=file, status="old")
		allocate(plinkInfo%referenceAllelePerSnps(lines))
		allocate(plinkInfo%alternateAllelePerSnps(lines))
		do i=1,lines
			read(unit, *) id, refAllele, minor
			snpId = plinkInfo%dict%getValue(id)
			if (snpId /= DICT_NULL) then
				plinkInfo%referenceAllelePerSnps(snpId) = refAllele
			else
				write(error_unit, *) "WARNING: snp " , id, " not found in map file"
			endif
		enddo
		close(unit)
	else
		write(error_unit,*) "Warning: no .ref file found for this dataset"
	endif

end subroutine readRef


subroutine writePedFile(ped,plinkInfo,params, paths)
	use AlphaHouseMod, only : countColumns
	use basespecfileModule
	integer :: nChroms

	class(basespecfile), intent(in) :: params
	type(plinkInfoType), intent(in) :: plinkInfo
	type(PedigreeHolder), intent(in) :: ped
	character(len=128), optional,dimension(:), allocatable, intent(in) :: paths !< output paths for each chromosome
	character(len=2), dimension(:,:), allocatable :: outputAlleles
	character(len=:),allocatable :: fmt
	integer(kind=1) :: phase1,phase2
	integer :: snpCounts = 0, pedUnit,i,nsnps,p,j
	allocate(outputAlleles(ped%pedigreeSize, plinkInfo%totalSnps*2)) !outputphase



	if (present(paths)) then
	
		do i =1,nChroms


			nsnps = countColumns(trim(paths(i))//"phase.txt", ' ') - 1
			call ped%addPhaseInformationFromFile(trim(paths(i))//"phase.txt",nsnps)

			do p=1,ped%pedigreeSize
			
				do j=1,nsnps,2
					
					phase1 = ped%pedigree(p)%individualPhase(1)%getPhase(j)
					phase2 = ped%pedigree(p)%individualPhase(2)%getPhase(j+1)

					snpCounts = snpCounts + 1
					if (phase1 == 1) then
						outputAlleles(i,snpCounts) = plinkInfo%referenceAllelePerSnps(snpCounts)
					else
						outputAlleles(i,snpCounts) = plinkInfo%alternateAllelePerSnps(snpCounts)
					endif

					snpCounts = snpCounts + 1
					if (phase2 == 1) then
						outputAlleles(i,snpCounts) = plinkInfo%referenceAllelePerSnps(snpCounts)
					else
						outputAlleles(i,snpCounts) = plinkInfo%alternateAllelePerSnps(snpCounts)
					endif

				enddo
			enddo
		enddo


		open(newunit=pedUnit,file=trim(params%resultFolderPath) //"PlinkOutput.ped", status='unknown')
		write(fmt, '(a,i10,a)') '(6a20,',2*plinkInfo%totalSnps, 'i2)'
		do p=1, ped%pedigreeSize
			write(pedUnit,  fmt) ped%pedigree(p)%originalId,ped%pedigree(p)%sireId,ped%pedigree(p)%damId,ped%pedigree(p)%gender,'0', outputAlleles(p,:)
		enddo

		close(pedunit)

	else 
	! TODO print out what is currently in ped
	endif
	
end subroutine writePedFile

end module CompatibilityModule


















